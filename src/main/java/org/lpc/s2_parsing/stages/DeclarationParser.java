package org.lpc.s2_parsing.stages;

import org.lpc.s1_tokenization.Token;
import org.lpc.s1_tokenization.TokenType;
import org.lpc.s2_parsing.ast.*;
import org.lpc.s2_parsing.ast.expression.ExpressionNode;
import org.lpc.s2_parsing.ast.statement.BlockNode;
import org.lpc.s2_parsing.ast.statement.StatementNode;
import org.lpc.s2_parsing.ast.statement.VariableDeclarationNode;

import java.util.ArrayList;
import java.util.List;

/**
 * The DeclarationParser class is responsible for parsing top-level declarations
 * from a list of tokens. It processes tokens generated by the lexer and converts
 * them into a list of AST nodes representing function and variable declarations.
 *
 * <p>
 * The main purpose of this class is to:
 * - Identify and parse function declarations.
 * - Identify and parse global variable declarations.
 * - Ensure that the tokens follow the syntax rules for declarations.
 * </p>
 */
public class DeclarationParser {
    private List<Token> tokens;
    private int current = 0;
    private ExpressionParser expressionParser;
    private StatementParser statementParser;

    /**
     * Parses the list of tokens and converts them into a list of AST nodes
     * representing top-level declarations.
     *
     * @return A list of AST nodes.
     */
    public ProgramNode parseDeclarations(List<Token> tokens) {
        this.expressionParser = new ExpressionParser(tokens, 0);
        this.statementParser = new StatementParser(tokens, 0, expressionParser);
        this.tokens = tokens;

        ProgramNode program = parseProgramDeclaration();

        while (!isAtEnd()) {
            // Parse variable declarations
            if (check(TokenType.CONST) || check(TokenType.SET)) {
                program.addChild(parseVariableDeclaration());
            }
            // Parse function declarations
            else if (check(TokenType.FUNC)) {
                program.addChild(parseFunctionDeclaration());
            }
            // Parse struct declarations
            else if (check(TokenType.STRUCT)) {
                program.addChild(parseStructDeclaration());
            }

            else {
                throw new SyntaxError("Unexpected token: " + peek().getValue());
            }
        }
        return program;
    }

    private ProgramNode parseProgramDeclaration() {
        consume(TokenType.PROGRAM, "Expected 'program' keyword at the beginning of the program");
        String name = consume(TokenType.IDENTIFIER, "Expected program name after 'program' keyword").getValue();
        consume(TokenType.SEMICOLON, "Expected ';' after program name");

        return new ProgramNode(name);
    }

    private GlobalVariableDeclarationNode parseVariableDeclaration() {
        GlobalVariableDeclarationNode declaration;
        boolean isConst = check(TokenType.CONST);

        // Consume the 'const' or 'set' keyword
        advance();

        // Parse the variable name
        Token name = consume(TokenType.IDENTIFIER, "Expected variable name after 'const' or 'set'");

        // Parse the variable type
        consume(TokenType.COLON, "Expected ':' after variable name");
        String type = parseType();

        // Parse the initializer expression
        consume(TokenType.EQUAL, "Expected '=' after variable type");

        ExpressionNode initializer = expressionParser.parseExpression(current);
        current = expressionParser.getCurrent();
        consume(TokenType.SEMICOLON, "Expected ';' after variable declaration");

        // Create the variable declaration node
        declaration = new GlobalVariableDeclarationNode(name.getValue(), type, initializer);
        if (isConst) {
            declaration.setConst();
        }

        return declaration;
    }

    private String parseType() {
        if (check(TokenType.LEFT_BRACKET)) {
            // Parse array type
            advance();
            Token elementType = consume(TokenType.IDENTIFIER, "Expected array element type");
            consume(TokenType.COMMA, "Expected ',' in array type");
            Token size = consume(TokenType.INTEGER, "Expected array size");
            consume(TokenType.RIGHT_BRACKET, "Expected ']' after array size");
            return "[" + elementType.getValue() + ", " + size.getValue() + "]";
        } else {
            // Parse primitive type
            return consume(TokenType.IDENTIFIER, "Expected type name").getValue();
        }
    }


    private FunctionDeclarationNode parseFunctionDeclaration() {
        consume(TokenType.FUNC, "Expected 'func' keyword at the beginning of the function declaration");

        // Parse the function name
        Token name = consume(TokenType.IDENTIFIER, "Expected function name after 'func' keyword");

        // Parse the parameter list
        consume(TokenType.LEFT_PAREN, "Expected '(' after function name");
        List<ParameterNode> parameters = parseParameters();
        consume(TokenType.RIGHT_PAREN, "Expected ')' after parameter list");

        // Parse the return type
        consume(TokenType.ARROW, "Expected '->' after parameter list");
        String returnType = parseType();

        // Parse the function body
        BlockNode body = statementParser.parseBlock(current);
        current = statementParser.getCurrent();

        return new FunctionDeclarationNode(name.getValue(), returnType, parameters, body);
    }

    private List<ParameterNode> parseParameters() {
        List<ParameterNode> parameters = new ArrayList<>();

        if (check(TokenType.IDENTIFIER)) {
            parameters.add(parseParameter());
        }

        while (check(TokenType.COMMA)) {
            advance();
            parameters.add(parseParameter());
        }

        return parameters;
    }

    private ParameterNode parseParameter() {
        Token name = consume(TokenType.IDENTIFIER, "Expected parameter name");
        consume(TokenType.COLON, "Expected ':' after parameter name");
        String type = parseType();
        return new ParameterNode(name.getValue(), type);
    }

    private ASTNode parseStructDeclaration() {
        return null;
    }



    // Other helper methods...

    private Token consume(TokenType type, String message) {
        if (check(type)) return advance();
        throw new RuntimeException(message);
    }

    private boolean check(TokenType type) {
        if (isAtEnd()) return false;
        return peek().getType() == type;
    }

    private Token advance() {
        if (!isAtEnd()) current++;
        return previous();
    }

    private Token advanceToString(String value) {
        while (!isAtEnd() && !peek().getValue().equals(value)) {
            advance();
        }
        return peek();
    }

    private Token advancePastLineEnd() {
        advanceToString(";");
        advance();
        return peek();
    }

    private boolean isAtEnd() {
        return peek().getType() == TokenType.EOF;
    }

    private Token peek() {
        return tokens.get(current);
    }

    private Token previous() {
        return tokens.get(current - 1);
    }
}

class SyntaxError extends RuntimeException {
    public SyntaxError(String message) {
        super(message);
    }
}