package org.lpc.s3_semantic_analysis;

import org.lpc.s2_parsing.ast.*;
import org.lpc.s2_parsing.ast.expression.type.TypeNode;
import org.lpc.s2_parsing.ast.statement.StructFieldNode;
import org.lpc.s3_semantic_analysis.symbols.FunctionSymbol;
import org.lpc.s3_semantic_analysis.symbols.StructSymbol;
import org.lpc.s3_semantic_analysis.symbols.VariableSymbol;

import java.util.List;
import java.util.stream.Collectors;

/**
 * The SemanticAnalyzer class is responsible for performing semantic analysis on the AST.
 * It processes the AST generated by the parser and performs checks to ensure that the
 * program follows the language's semantic rules.
 *
 * <p>
 *     Rules checked by the SemanticAnalyzer include:
 *     - Variable / Function / Struct declarations must be unique.
 *     - Variables / Functions / Structs must be declared before they are used.
 *     - Type checking
 *     - Scope checking
 *
 */
public class SemanticAnalyzer {
    private final SymbolTable symbolTable = new SymbolTable();

    public void analyze(ProgramNode program) {
        for (ASTNode stmt : program.getChildren()) {
            analyzeNode(stmt);
        }

        System.out.println("Semantic Analysis Complete");
    }

    private void analyzeNode(ASTNode stmt) {
        if (stmt instanceof GlobalVariableDeclarationNode) {
            analyzeGlobalVariableDeclaration((GlobalVariableDeclarationNode) stmt);
        } else if (stmt instanceof FunctionDeclarationNode) {
            analyzeFunctionDeclaration((FunctionDeclarationNode) stmt);
        } else if (stmt instanceof StructDeclarationNode) {
            analyzeStructDeclaration((StructDeclarationNode) stmt);
        } else {
            throw new RuntimeException("Unknown node type: " + stmt.getClass());
        }
    }

    private void analyzeGlobalVariableDeclaration(GlobalVariableDeclarationNode node) {
        if (symbolTable.isDeclared(node.getName())) {
            throw new RuntimeException("Variable already declared: " + node.getName());
        } else {
            symbolTable.declare(node.getName(), new VariableSymbol(node.getName(), node.getType().getTypeName(), node.isConst()));
        }
    }

    private void analyzeFunctionDeclaration(FunctionDeclarationNode node) {
        if (symbolTable.isDeclared(node.getName())) {
            throw new RuntimeException("Function already declared: " + node.getName());
        } else {
            String name = node.getName();
            String returnType = node.getReturnType().getTypeName();
            List<String> parameterTypes = node.getParameters().stream().map(ParameterNode::getType).map(TypeNode::getTypeName).toList();
            symbolTable.declare(name, new FunctionSymbol(name, parameterTypes, returnType));

            // Enter new scope for function parameters
            symbolTable.enterScope();

            // Declare function parameters in the new scope
            for (ParameterNode param : node.getParameters()) {
                symbolTable.declare(param.getName(), new VariableSymbol(param.getName(), param.getType().getTypeName(), false));
            }

            // Analyze function body
            for (ASTNode stmt : node.getBody().getChildren()) {
                //analyzeNode(stmt);
            }

            // Exit function scope
            symbolTable.exitScope();
        }
    }

    private void analyzeStructDeclaration(StructDeclarationNode node) {
        if (symbolTable.isDeclared(node.getName())) {
            throw new RuntimeException("Struct already declared: " + node.getName());
        } else {
            String name = node.getName();
            List<StructFieldNode> fields = node.getFields();
            StructSymbol structSymbol = new StructSymbol(name, fields.stream().collect(Collectors.toMap(StructFieldNode::getFieldName, field -> field.getFieldType().getTypeName())));

            symbolTable.declare(name, structSymbol);

            // Enter new scope for struct fields (optional, depending on language rules)
            symbolTable.enterScope();

            for (StructFieldNode field : fields) {
                if (symbolTable.isDeclared(field.getFieldName())) {
                    throw new RuntimeException("Field already declared: " + field.getFieldName());
                } else {
                    symbolTable.declare(field.getFieldName(), new VariableSymbol(field.getFieldName(), field.getFieldType().getTypeName(), false));
                }
            }

            // Exit struct scope
            symbolTable.exitScope();
        }
    }
}
